# 開発者用説明書

このファイルではこの路線データの技術的内部仕様を説明する。

## ファイル構成

この路線データのファイルは以下のサブフォルダーに分かれている。

 - map
 - map_misc
 - map_parts
 - signals
 - stations
 - structures

signals フォルダーには信号現示リストが入っている。
stations フォルダーには停車場リストが入っている。

マップファイルはいくつかのフォルダーに分かれている。

Git のレポジトリーをチェックアウトした直後は、map フォルダーには build.sh というスクリプトファイルしか入っていない。このスクリプトを実行することで、map フォルダー内にマップファイルがたくさん生成される。生成されたマップファイルは、シナリオファイルで `Route = ...` に指定する。これには複数のマップファイルを指定でき、それによりシナリオ起動時にランダムにマップファイルが選択される。こうして毎回異なるマップが読み込まれる。

map_parts フォルダーにあるファイルは、パートファイルと呼んでいる。パートファイルは、map フォルダーにあるマップファイルから `include` される。パートファイルはその中で数百メートル分 (基本的には一閉塞分) の線路を生成し、その区間内にストラクチャーや地上子を配置する。マップファイルがパートファイルをどんどん `include` することで順次路線が生成されてゆくということである。どのパートファイルをどの順番で `include` するかはマップファイルによって異なる。また同じパートファイルでも内部で `rand` 関数を使用して様々なパラメーターをランダムに決定するため異なる線形や地形が生成される。

map_misc フォルダーにあるファイルは上記以外のマップファイルであり、基本的にはパートファイルから `include` される。ここにあるファイルは変数を初期化したり地上子をまとめて設置したりといった共通処理を行う。

## 停車場リスト

停車場リストファイルは `stations_<時刻>h_<ID>.csv` 形式のファイル名をしており、例えば `stations_9h_0.csv` のようになる。

`<時刻>` は最後の駅に到着する時刻が何時台かを示している。例えば `stations_9h_0.csv` は最後の駅に午前 9 時台に到着するダイヤである。

`<ID>` は停車場リストのバリエーションの番号である。ID ごとに停車場リストの中身 (特に駅名) が異なっている。

マップファイルからランダムに停車場リストファイルを選んで読み込むことで、駅名とダイヤが毎回変化するようにしてある。停車場リストファイルの内容を動的に生成することはできないので、駅名やダイヤはファイルごとに一定である。また、先行列車との間隔調整のために、先行列車が始発駅を出る時刻に応じて停車場リストファイルを選択するようにしてある。

## マップファイルの生成

map フォルダーにある build.sh というシェルスクリプトファイルを実行することでマップファイルが大量に生成される。また、シナリオファイルに記載すべき `Route = ...` の値が標準出力に出力される。

このスクリプトは bash 用であり、Cygwin 等の Unix 系環境で実行する必要がある。(Windows 標準の cmd.exe や PowerShell では実行できない。)

なお、生成されるマップファイルが読み込むパートファイルの種類や順番はスクリプトを実行するたびに毎回ランダムに変化する。

各パートファイルは路線を**逆方向**に生成してゆくことに注意すること。例えば一つ目のパートファイルが距離程 12300～12500 メートルの区間を生成したら、次のパートファイルは例えば 12000～12300 メートル区間を生成する (12500～12700 メートル区間とかではない)。念のため用語の意味を明示しておく:

 - 手前 (preceding) = 距離程の数字がより小さい
 - 後 (following) = 距離程の数字がより大きい
 - 次 (next) のパートファイル = より後に `include` されるパートファイル = より手前の区間を生成するパートファイル
 - 前 (previous) のパートファイル = より先に `include` されるパートファイル = より後の区間を生成するパートファイル

### パートファイルの選択

各パートファイルには、`//FOLLOWS: <ファイル名>` という形式のコメントが一つ以上書かれている。これにより、そのパートファイルが `include` された後にどのパートファイルが `include` されるか (つまりそのパートファイルが生成する区間の手前にどのような区間が生成されるか) が決まる。コメントが複数ある場合はそれらの中からランダムに次のパートファイルが選択される。同じファイル名を指すコメントを何度も書くことでそのファイルが選ばれる確率が上がる。

パートファイルの中に `//DUMMY` というコメントがある場合、そのパートファイルはダミーとみなされる。ダミーのパートファイルは `include` されず、そこに書かれている `//FOLLOWS:` のファイル名に従って再度パートファイルが選択される。

ダミーファイルは、主に複数のパートファイルからランダムに選ぶのをやりやすくするために使用する。例えば grassland_s_any.txt というダミーファイルには名前が grassland_s で始まる種々のパートファイル (どれも草原を走る単線のパート) が `//FOLLOWS:` 対象として書かれている。他のパートファイルに `//FOLLOWS:` を記載する際、たくさんのパートファイルをいちいち `//FOLLOWS:` に列挙する代わりにダミーファイルを `//FOLLOWS:` に指定することで、 `//FOLLOWS:` の記述量も減るし、また新たに草原を走る単線のパートファイルが増えたときにはダミーファイルを書き換えるだけで他のパートファイルの手前として候補に加えることができる。

なお、各マップファイルで最初に読み込まれるパートファイルは必ず any.txt で、これは全てのパートファイルからランダムに選択するためのダミーのファイルである。

パートファイルの中に `//STATION` というコメントがある場合、そのパートファイルは駅である。駅のパートファイルはちょうど一つの `Station[...].Put(...)` 文を含む。パートファイルが駅であるかどうかの区別は build.sh が生成するマップファイルの長さに影響する。一定数の駅を `include` したところでマップファイルが終了する。

## マップファイルで使う変数

マップファイルで使う変数は、名前によりスコープを区別している。

 - `$` の直後にアルファベットが来る変数 (例: `$location`) は全てのファイルにわたって横断的に使用する変数である。このタイプの変数はパートファイル間で値が引き継がれる。
 - `$` の直後に一つ `_` が付く変数 (例: `$_begin`) はそのパートファイル内で固有の変数である。このタイプの変数はそれが定義されたパートファイル内でのみ使用され、他のパートファイルで使用されることはない。ただし、そのパートファイルが `include` するファイルと値をやり取りするために使用されることはある。
 - `$` の直後に二つ `_` が付く変数 (例: `$__start_hour`) は、map_misc ディレクトリーにあるマップファイルの中で定義され、そのファイル内のみで使用される。

### グローバル変数

`$` の直後にアルファベットが来る変数はパートファイル間で様々なデータを引き継ぐために使用する。以下はそのような変数の一覧である。一つのパートファイルの処理が終わり次のパートファイルの処理に移るとき、変数の値は以下に説明する通りになっている必要がある。

 - `$location` = パートファイルが切り替わる地点の位置。
 - `$pretrain_time` = `$location` の位置を先行列車が通過する時刻 (0 時からの秒数)。
 - `$pretrain_departure_time` = 一つ後の駅を先行列車が出発する時刻 (0 時からの秒数)。すなわち自車が一つ後の駅に入れるようになる時刻。
 - `$preceding_station_number` = 次に駅のパートファイルが `include` された時に生成される駅の番号。駅の番号は始発駅が 0 で、終着駅に向かって 1, 2, 3, ... と上がってゆく。
 - `$following_station_location` = 一つ後の駅の停止位置。
 - `$following_section_location_1`, ..., `$following_section_location_7` = 一つ後から七つ後までの各閉塞の開始位置。
 - `$following_section_signal_1`, ..., `$following_section_signal_7` = 先行列車が 1, ..., 7 閉塞先にいる時における、一つ後の閉塞の信号インデックス。
 - `$section_count` = `$location` の位置における閉塞の番号。

以下は全てのパートファイルで使われる変数ではあるが、最初のパートファイルが `include` される前に初期化され、各パートファイルの中では変更されない。

 - `$max_location` = 路線の最終地点の距離程。
 - `$max_speed` = 路線の最高速度 (km/h)。5 の倍数。
 - `$has_cab_signal` = 車内信号式なら 1、線路脇信号式なら 0。
 - `$is_std_signal` = 通常の信号インデックス 0, ..., 5 を使用する路線なら 1、それ以外なら 0。
 - `$is_csatc` = CS-ATC 路線なら 1、それ以外なら 0。
 - `$signal_speed_1`, ..., `$signal_speed_4` = 信号インデックス 1, ..., 4 の制限速度 (km/h)。 `$is_std_signal` が 0 の路線では非常に大きな値。
 - `$tasc_long_beacon_type` = 前の駅の停止位置の 11 メートル先に設置する TASC 地上子の種別番号。
 - `$tasc_500m_beacon_type` = 停車駅の停止位置の 500 メートル手前に設置する TASC 地上子の種別番号。
 - `$tasc_11m_beacon_type` = 停車駅の停止位置の 11 メートル手前に設置する TASC 地上子の種別番号。
 - `$ats_stop_beacon_type` = ATS-P 即時停止地上子の種別番号。
 - `$ats_stop_beacon_section` = ATS-P 即時停止地上子に対応させる閉塞。
 - `$ats_update_1_beacon_type` = 一つ先の閉塞の信号現示を送るための地上子の種別番号。閉塞の 25, 50, 85, 130, 180, 280, 600 メートル手前に設置される。
 - `$ats_update_2_beacon_type` = 二つ先の閉塞の信号現示を送るための地上子の種別番号。閉塞の 25, 50, 85, 130, 180, 280, 600 メートル手前に設置される。
 - `$ats_update_m1_beacon_type` = この先の停止信号の位置を送るための地上子の種別番号。閉塞の 25, 50, 85, 130, 180, 280, 600 メートル手前に設置される。
 - `$ats_update_1_beacon_value`, `$ats_update_2_beacon_value`, `$ats_update_m1_beacon_value` = 上記それぞれの地上子に送る値。
 - `$ats_update_transponder` = 上記地上子のストラクチャーキー。
 - `$conductor_timing_beacon_type` = 戸閉後に車掌が合図ブザーを鳴らすまでの時間を設定する地上子の種別番号。
 - `$max_section_count` = (標識ストラクチャーが存在する) 閉塞の番号の最大値。
 - `$ballast_5m_count` = `ballast_5m_<ID>` ストラクチャーのバリエーション。

なお、距離の単位は全てメートルである。

## 計算式

 - max(x, 0) = (x + abs(x)) / 2
 - min(x, 0) = (x - abs(x)) / 2
 - max(x, y) = (x + y + abs(x - y)) / 2
 - min(x, y) = (x + y - abs(x - y)) / 2
 - (x が 0 または 1 であるとき) if x = 0 then 1 else 0 = 1 - x
 - (x が 0 または 1 であるとき) if x = 0 then 0 else y = x * y
 - if x is integer then 0 else 1 = ceil(x) - floor(x)
 - (x が 0 でないとき) if x > 0 then 1 else -1 = x / abs(x)
 - if x = 0 then 0 else 1 = ceil(min(abs(x), 1))
 - (0 <= x <= N のとき) if x = 0 then 0 else 1 = ceil(x / N)
